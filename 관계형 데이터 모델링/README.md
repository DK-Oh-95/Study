# [관계형 데이터 모델링]

## ERD의 구성요소 (Entity-relationship data model)

#### 1. Entity

- 실체, 객체라는 의미
  - 모델의 관리 대상 (entity)
  - 각 객체의 분류는 entity type이라고 함
    - ex. 학생 (entity type) / 김싸피, 이싸피 (entity)
  - 변별할 수 있는 사물, DB 내에서 변별 가능한 객체, 정보를 저장할 수 있는 것, 정보가 될 수 있는 사람 ,장소, 물건, 사건, 개념 등
  - ER 다이어그램에서 사각형으로 표현
- Attribute(속성, 구체적인 데이터)로 구성
- 추후 table로 전환
  - Attribute는 table의 column으로 치환
  - 행은(row) tuple이라고 부름
- 분류
  - 유무형에 따른 분류
    - **유형 엔터티** : 물리적인 형태가 있고, 안정적이며 지속적으로 활용되는 엔터티
    - **개념 엔터티** : 물리적인 형태는 존재하지 않고, 개념적 정보로 구분되는 엔터티
    - **사건 엔터티** : 업무를 수행함에 따라 발생되는 엔터티로 비교적 발생량이 많으며 각종 통계에 이용될 수 있음
  - 발생 시점에 따른 분류
    - **기본/키 엔터티** : 업무에 원래 존재하는 정보, 관계에 의해 생성되지 않고 독립적으로 생성 가능, 타 엔터티의 부모역할, 타 엔터티로부터 주식별자를 상속받지 않고 자신의 고유한 주식별자를 갖는다
    - **중심 엔터티** : 기본엔터티로부터 발생, 업무에서 중심적인 역할, 데이터 양이 많고 타 엔터티와의 관계를 통해 많은 행위 엔터티를 생성
    - **행위 엔터티** : 두 개 이상의 부모엔터티로부터 발생되고 자주 내용이 바뀌거나 데이터량이 증가



#### 2. Attribute

- **"Entity의 구성 요소", "인스턴스로 관리하고자 하는 의미상 더는 분리되지 않는 최소의 데이터 단위"**

- 특징
  - 다양하게 존재하는 인스턴스들에 대해 유일하게 구별할 수 있는 주식별자를 통해서 식별될 수 있어야 함
  - 하나의 속성에는 단 하나의 값만을 가짐
  - ER 다이어그램에서 마름모로 표현
- 분류
  - 특성에 따른 분류
    - **기본 속성 (Basic Attribute)** : 업무 분석을 통해 바로 정의한 속성. 가장 일반적이고 많은 속성을 차지
    - **설계 속성 (Designed Attribute)** : 업무상 필요한 데이터 이외에 데이터 모델링을 위해, 업무를 규칙화하기 위해 새로 만들어지거나 변형된 속성
    - **파생 속성 (Derived Attribute)** : 다른 속성에 영향을 받아 발생하는 속성. 일반적으로 계산된 값들이 해당됨
  - 엔터티 구성방식에 따른 분류
    - **PK 속성** : 엔터티를 유일하게 구분할 수 있는 속성
    - **FK 속성** : 다른 엔터티와의 관계에 포함된 속성
    - **일반 속성** : 엔터티에 포함되어 있고, PK 또는 FK에 포함되지 않는 속성
  - 세부 의미 유무에 따른 분류
    - **단순 속성 (Simple Attribute)** : 더 이상 다른 속성들로 구성될 수 없는 속성
    - **복합 속성 (Composite Attribute)** : 여러 세부 속성들로 구성될 수 있는 속성
    - **다치 속성 (Multivalue Attribute)** : 속성 하나에 여러 값이 들어갈 수 있는 속성
    - **유도 속성 (Derived Attribute)** : 실제 값이 저장되어 있는 것이 아니라 저장된 값으로부터 계산해서 얻은 값을 사용하는 속성
- **"도메인(Domain)"**
  - 각 속성은 무한정적인 값을 갖는 것이 아니라 범위가 지정되는데, 이 때 속성의 값이 가질 수 있는 범위를 그 속성의 도메인이라 함



#### 3. Relation

- Entity들 간의 관계 (1:N, M:N)
- PK(Primary Key, 기본키), FK(Forein Key, 외래키)로 table에서전환
- 특징
  - 한 개의 엔터티는 두 개 이상의 인스턴스의 집합
  - 한 개의 엔터티는 두 개 이상의 속성을 가진다
  - 한 개의 속성은 한 개의 속성 값을 가진다
  - ER 다이어그램에서 마름모로 표현

![image-20211228013454954](./img\image-20211228013454954.png)

- 관계 타입의 차수
  - 참여하고 있는 엔터티 타입의 개수
  - **순환적 관계** : 차수가 1인 관계

![image-20211228013815330](./img\image-20211228013815330.png)



---



# [Database / SQL]



## 1. 인덱스(Index)란?



- **"데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료 구조"**
- 특정 column에 인덱스를 생성하면 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장됨
- 책의 목차처럼 원하는 데이터를 먼저 찾고, 저장된 물리적 주소로 찾아감
- 실제 DB 작업 관련 속도 저하의 대부분은 Select문 조건 검색 Where절에서 발생하는데, 해결 방안 중 하나

![image-20211228110305701](./img\image-20211228110305701.png)

- 사용 이유
  - 조건 검색 Where 절의 효율성
    - 데이터가 쌓일 때 테이블의 레코드는 재부적으로 순서가 없이 저장됨
    - 이 때 where 절에 특정 조건에 맞는 데이터를 찾을 때 레코드 전부를 탐색해야함 >> Full Table Scan
    - 인덱스 테이블은 데이터들이 정렬되어 있기 때문에 빠르게 해당 조건 데이터를 찾아낼 수 있음
  - 정렬 Order by 절의 효율성
    - Order by에 의한 Sort 과정을 생략할 수 있음 (부하가 많이 걸리는 작업)
    - 정렬과 동시에 1차적으로 메모리에서 정렬이 이루어지며 메모리보다 큰 작업이 필요하다면 디스크 I/O도 추가적으로 발생
    - 인덱스를 사용하면 이미 정렬된 데이터를 가져오기만 하면 됨
  - MIN, MAX의 효율적인 처리 가능
    - MIN, MAX 값을 레코드의 시작과 끝 값만 가져오면 됨 (정렬되어 있기 때문)
- 단점
  - **졍렬된 상태를 계속 유지 시켜줘야 한다**
  - INSERT, UPDATE, DELETE를 통해 데이터가 추가되거나 값이 바뀐다면 인덱스 테이블 내의 값들을 다시 정렬 해야함
  - 테이블의 전체 데이터 중에서 10~15%의 데이터를 처리하는 경우에만 효율적
  - 인덱스를 관리하기 위해서는 DB의 약 10%에 해당하는 저장공간이 추가로 필요

- 인덱스 관리
  - 데이터 수정에 따른 부하를 최소화하기 위해 인덱스는 데이터 삭제라는 개념 대신 인덱스를 사용하지 않는다라는 작업 수행
    - INSERT : 새로운 데이터에 대한 인덱스를 추가
    - DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 진행
    - UPDATE : 기존 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스 추가

- B * Tree 인덱스
  - Balanced Tree 인덱스 구조 : 가장 많이 사용되는 인덱스 구조
  - 특히, B*Tree / B+Tree 구조 많이 사용
  - 대부분의 DBMS와 오라클에서 중점적으로 사용하고 있는 가장 보편적인 인덱스
  - 구조
    - Root(기준) / Branch(중간) / Leaf(말단) Node
  - 특정 컬럼에 인덱스를 생성하는 순간 컬럼의 값들을 정렬하는데, 정렬한 순서가 중간 쯤 되는 데이터를 뿌리에 해당하는 Root 블록으로 지정하고 Root 블록을 기준으로 가지가 되는 Branch 블록을 정의하며 마지막으로 앞에 해당하는 Leaf 블록에 인덱스의 키가 되는 데이터와 데이터의 물리적 주소 정보인 RowId를 저장

![image-20211228121414841](./img\image-20211228121414841.png)



## 2. SQL



- **"데이터베이스에 담긴 수많은 양의 데이터를 다루는 언어"**
  - SQL을 통해 내가 사용하고자 하는 목적에 부합하는 정보만 추출
- Structured Query Language, 구조화 질의어
- 구분
  - **데이터 정의어 (DDL)** : 데이터 간의 관계를 정의하여 데이터베이스 구조를 설정하는 문장
  - **데이터 조작어 (DML)** : 데이터베이스 내의 저장된 데이터를 추출, 수정, 삽입, 삭제하는 문장
  - **데이터 제어어 (DCL) : 데이터베이스에 접근하고 객체를 사용하는 권한을 주거나 회수하는 문장
- 기능
  - 데이터베이스를 생성할 수 있다
  - 데이터베이스 내의 정보를 검색(쿼리)할 수 있다
  - 필요한 정보를 검색하는 쿼리문을 자동화할 수 있다
  - 필요한 데이터만 모아볼 수 있는 가상의 뷰를 만들 수 있다

- 구성
  - **스키마(Schema)** : 데이터베이스 구조에 대해 자세히 적어놓은 설명서
  - **테이블(Table)** : 데이터를 주제별로 모아둔 데이터 집합
  - **컬럼(Column)** : 데이터 분류 개체 = **필드(Field)**
  - **행(Row)** : 실제 데이터 = **레코드(Record)**





---



# 과제 수행 느낀점



- 데이터베이스 설계 시 생각보다 세부적인 부분 설정이 난해하다
- 관계 설정 시 객체의 속성을 다른 테이블로 뺄지 속성에서 관계선 연결만 할 지 애매하다
- 초기 데이터베이스 설정을 가능한 세세하게 설정할 필요가 있다







자료 출처 : https://coding-factory.tistory.com/746

https://3rdscholar.tistory.com/33?category=897833

